{
    "CP Template": {
        "prefix": "cp",
        "body": [
            "/**",
            " *    author:  devangsvaghani",
            " *    created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            "**/",
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifndef ONLINE_JUDGE",
            "#include \"dev/debug.hpp\"",
            "#else",
            "#define debug(...) 8",
            "#endif",
            "",
            "typedef long long ll;",
            "typedef unsigned long long ull;",
            "typedef long double lld;",
            "",
            "#define all(x) (x).begin(), (x).end()",
            "#define f(i, x, n) for (ll i = x; i < n; i++)",
            "#define rf(i, x, n) for (ll i = x; i >= n; i--)",
            "",
            "const ll mod = 1e9+7;",
            "const ll mod2 = 998244353;",
            "const ll N = 1e6+5;",
            "",
            "void init(){",
            "    ",
            "}",
            "",
            "void solve(){",
            "    $0",
            "}",
            "",
            "int main() {",
            "    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
            "",
            "    // #ifndef ONLINE_JUDGE",
            "    //   freopen(\"input.txt\", \"r\", stdin);",
            "    //   freopen(\"output.txt\", \"w\", stdout);",
            "    //   freopen(\"Error.txt\", \"w\", stderr);",
            "    // #endif",
            "",
            "    init();",
            "    ",
            "    ll t = 1;",
            "    cin >> t;",
            "    for (ll T = 1; T <= t; T++) {",
            "        // debug(T);",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "CP Template"
    },
    "Ordered Set Libraries": {
        "prefix": "ordered_set_include",
        "body": [
            "#include<ext/pb_ds/assoc_container.hpp>",
            "#include<ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "// find_by_order && order_of_key",
            "template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
            ""
        ],
        "description": "Ordered Set"
    },
    "Binary Exponentiation": {
        "prefix": "Binary Power",
        "body": [
            "// Binary Exponentiation",
            "long long binPower(long long a, long long b, long long m){",
            "    long long res = 1;",
            "    a %= m;",
            "    while(b > 0){",
            "        if(b & 1) res = (res * a) % m;",
            "        a = (a * a) % m;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Binary Exponentiation"
    },
    "Factorial Precomputation": {
        "prefix": "Factorial Inverse Precomputation",
        "body": [
            "// Factorial & inverse Factorial Calculation",
            "const long long factSize = 2e6 + 5;",
            "long long fact[factSize];",
            "long long invFact[factSize];",
            "",
            "void preComputeFact(){",
            "    fact[0] = 1;",
            "    for(long long i = 1; i < factSize; ++i){",
            "        fact[i] = (fact[i - 1] * i) % mod;",
            "    }",
            "    invFact[factSize - 1] = binPower(fact[factSize - 1], mod - 2, mod);",
            "    for(long long i = factSize - 2; i >= 0; --i){",
            "        invFact[i] = (invFact[i + 1] * (i + 1)) % mod;",
            "    }",
            "}"
        ],
        "description": "Factorial Precomputation"
    },
    "nCr": {
        "prefix": "nCr",
        "body": [
            "// nCr Calculation",
            "long long nCr(long long n, long long r){",
            "    if(r < 0 || r > n) return 0ll;",
            "    return ((fact[n] * invFact[n - r]) % mod * invFact[r]) % mod; ",
            "}"
        ],
        "description": "nCr"
    },
    "Derangement - Permutation such that no element appears in its original position": {
        "prefix": "Derangement",
        "body": [
            "// Derangement - Permutation such that no element appears in its original position",
            "// D[n] = (D[n - 1] + D[n - 2]) * (n - 1);",
            "// D[1] = 0, D[2] = 1;",
            "const long long derangementSize = 1e6 + 1;",
            "long long derangement[derangementSize];",
            "",
            "void preComputeDerangement(){",
            "    derangement[1] = 0;",
            "    derangement[2] = 1;",
            "",
            "    for(long long i = 3; i < derangementSize; ++i){",
            "        derangement[i] = (((derangement[i - 1] + derangement[i - 2])) % mod * (i - 1)) % mod;",
            "    }",
            "}"
        ],
        "description": "Derangement - Permutation such that no element appears in its original position"
    },
    "No. of Divisors Precomputation": {
        "prefix": "Divisors Count",
        "body": [
            "// Count number of divisors",
            "const long long divisorSize = 1e6 + 1;",
            "long long divisorsCnt[divisorSize];",
            "",
            "void preComputeDivisorsCnt(){",
            "    divisorsCnt[0] = 1;",
            "",
            "    for (long long i = 1; i * i < N; ++i){",
            "        divisorsCnt[i * i]--;",
            "        for (long long j = (i * i); j < N; j += i){",
            "            divisorsCnt[j] += 2;",
            "        }",
            "    }",
            "}",
            "",
            "bool isPrime(long long n){",
            "    return (bool)(divisorsCnt[n] == 2);",
            "}"
        ],
        "description": "No. of Divisors Precomputation"
    },
    "Eular totient function O(sqrt(n))": {
        "prefix": "phi fucntion for single number",
        "body": [
            "// Eular totient function O(sqrt(n))",
            "long long singlePhi(long long n){",
            "  long long result = n;",
            "  for(long long i = 2; i * i <= n; ++i){",
            "    if(n % i == 0){",
            "      while(n % i == 0) n /= i;",
            "      result -= result / i;",
            "    }",
            "  }",
            "",
            "  if(n > 1){",
            "    result -= result / n;",
            "  }",
            "  return result;",
            "}"
        ],
        "description": "Eular totient function O(sqrt(n))"
    },
    "Eular totient function - Precomputation": {
        "prefix": "phi fucntion",
        "body": [
            "// Eular totient function - Precomputation",
            "const long long phiSize = 1e6 + 1;",
            "long long phi[phiSize];",
            "",
            "void preComputePhi(){",
            "  for(long long i = 0; i < phiSize; ++i) phi[i] = i;",
            "",
            "  for(long long i = 2; i < phiSize; ++i){",
            "    if(phi[i] == i){",
            "      for(long long j = i; j < phiSize; j += i){",
            "        phi[j] -= phi[j] / i;",
            "      }",
            "    }",
            "  }",
            "}"
        ],
        "description": "Eular totient function - Precomputation"
    },
    "Optimised Sieve specially for N = 1e8": {
        "prefix": "Optimised Sieve",
        "body": [
            "// Optimised Sieve specially for N = 1e8",
            "const long long sieveSize = 1e8+1;",
            "bool prime[sieveSize];",
            "vector<long long> ps;",
            "",
            "void preComputeSieve(){",
            "    for(long long i = 0; i < sieveSize; i++) prime[i] = true;",
            "    for(long long i = 3; i * i < sieveSize; i += 2){",
            "        if(prime[i / 2]){",
            "            for(long long j = i * i; j < sieveSize; j += i * 2){",
            "                prime[j / 2] = false;",
            "            }",
            "        }",
            "    }",
            "",
            "    ps.push_back(2);",
            "    for(long long i = 3; i < sieveSize; i += 2){",
            "        if(prime[i / 2]){",
            "            ps.push_back(i);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Optimised Sieve specially for N = 1e8"
    },
    "Sieve for prime numbers": {
        "prefix": "Sieve",
        "body": [
            "// Sieve for prime numbers",
            "const long long sieveSize = 1e7+1;",
            "bool prime[sieveSize];",
            "vector<long long> primes;",
            "",
            "void preComputeSieve(){",
            "    for(long long i = 2; i < sieveSize; ++i) prime[i] = true;",
            "    for(long long i = 2; i < sieveSize; ++i){",
            "        if(prime[i]){",
            "                primes.push_back(i);",
            "            for(long long j = i * i; j < sieveSize; j += i){",
            "                prime[j] = false;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sieve for prime numbers"
    },
    "DSU": {
        "prefix": "DSU",
        "body": [
            "class DSU{",
            "public:",
            "    long long n;",
            "    vector<long long> size, par;",
            " ",
            "    DSU(long long n){",
            "        this -> n = n;",
            "        size.resize(n);",
            "        par.resize(n);",
            " ",
            "        for(long long i = 0; i < n; ++i){",
            "            par[i] = i;",
            "            size[i] = 1;",
            "        }",
            "    }",
            " ",
            "    long long find(long long u){",
            "        if (u == par[u])",
            "            return u;",
            "        return par[u] = find(par[u]);",
            "    }",
            " ",
            "    void merge(long long u, long long v){",
            "        u = find(u); v = find(v);",
            "        if (u == v) return;",
            "",
            "        if (size[u] < size[v]){",
            "            swap(u, v);",
            "        } ",
            "        size[u] += size[v];",
            "        par[v] = u;",
            "    }",
            " ",
            "    long long count_components(){",
            "        long long cnt = 0;",
            "        for (long long i = 1; i < n; ++i){",
            "            if (par[i] == i) ++cnt;",
            "        }",
            " ",
            "        return cnt;",
            "    }",
            "};"
        ],
        "description": "DSU"
    },
    "2-SAT (Boolean satisfiability problem)": {
        "prefix": "2-SAT",
        "body": [
            "struct TwoSatSolver {",
            "    int n_vars;",
            "    int n_vertices;",
            "    vector<vector<int>> adj, adj_t;",
            "    vector<bool> used;",
            "    vector<int> order, comp;",
            "    vector<bool> assignment;",
            "",
            "    TwoSatSolver(int _n_vars) : n_vars(_n_vars), n_vertices(2 * n_vars), adj(n_vertices), adj_t(n_vertices), used(n_vertices), order(), comp(n_vertices, -1), assignment(n_vars) {",
            "        order.reserve(n_vertices);",
            "    }",
            "    void dfs1(int v) {",
            "        used[v] = true;",
            "        for (int u : adj[v]) {",
            "            if (!used[u])",
            "                dfs1(u);",
            "        }",
            "        order.push_back(v);",
            "    }",
            "",
            "    void dfs2(int v, int cl) {",
            "        comp[v] = cl;",
            "        for (int u : adj_t[v]) {",
            "            if (comp[u] == -1)",
            "                dfs2(u, cl);",
            "        }",
            "    }",
            "",
            "    bool solve_2SAT() {",
            "        order.clear();",
            "        used.assign(n_vertices, false);",
            "        for (int i = 0; i < n_vertices; ++i) {",
            "            if (!used[i])",
            "                dfs1(i);",
            "        }",
            "",
            "        comp.assign(n_vertices, -1);",
            "        for (int i = 0, j = 0; i < n_vertices; ++i) {",
            "            int v = order[n_vertices - i - 1];",
            "            if (comp[v] == -1)",
            "                dfs2(v, j++);",
            "        }",
            "",
            "        assignment.assign(n_vars, false);",
            "        for (int i = 0; i < n_vertices; i += 2) {",
            "            if (comp[i] == comp[i + 1])",
            "                return false;",
            "            assignment[i / 2] = comp[i] > comp[i + 1];",
            "        }",
            "        return true;",
            "    }",
            "",
            "    void add_disjunction(int a, bool na, int b, bool nb) {",
            "        // na and nb signify whether a and b are to be negated ",
            "        a = 2 * a ^ na;",
            "        b = 2 * b ^ nb;",
            "        int neg_a = a ^ 1;",
            "        int neg_b = b ^ 1;",
            "        adj[neg_a].push_back(b);",
            "        adj[neg_b].push_back(a);",
            "        adj_t[b].push_back(neg_a);",
            "        adj_t[a].push_back(neg_b);",
            "    }   ",
            "",
            "    // how to use",
            "",
            "    // Nodes are from 0 to n - 1 ( 0 indexded )",
            "",
            "    // TwoSatSolver solver(3); // a, b, c",
            "    // solver.add_disjunction(0, false, 1, true);  //     a  v  not b",
            "    // solver.add_disjunction(0, true, 1, true);   // not a  v  not b",
            "    // solver.add_disjunction(1, false, 2, false); //     b  v      c",
            "    // solver.add_disjunction(0, false, 0, false); //     a  v      a",
            "    // assert(solver.solve_2SAT() == true);",
            "    // auto expected = vector<bool>(True, False, True);",
            "    // assert(solver.assignment == expected);",
            "};"
        ],
        "description": "2-SAT (Boolean satisfiability problem)"
    },
    "Segment tree": {
        "prefix": "Segment tree",
        "body": [
            "struct segNode{",
            "    long long sum;",
            "    ",
            "    segNode(){",
            "        sum = 0;",
            "    }",
            "    ",
            "    void merge(segNode &x, segNode& y){",
            "        sum = x.sum + y.sum;",
            "    }",
            "    ",
            "    void update(long long val){",
            "        sum = val;",
            "    } ",
            "};",
            " ",
            "class segTree{",
            "    long long n;",
            "    vector<segNode> tree;",
            "    ",
            "    public:",
            "    segTree(){}",
            " ",
            "    segTree(long long n){",
            "        this -> n = n;",
            "        tree.resize(4 * n);",
            "    }",
            " ",
            "    segTree(vector<long long> &v, long long n){",
            "        this -> n = n;",
            "        tree.resize(4 * n);",
            "        fill(all(tree), segNode());",
            "    ",
            "        build(1, 0, n-1, v);",
            "    }",
            "    ",
            "    void build(long long node, long long l, long long r, vector<long long> &v){",
            "        if(l == r){",
            "            tree[node].update(v[l]);",
            "            return;",
            "        }",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        build(node << 1, l, mid, v);",
            "        build(node << 1 | 1, mid + 1, r, v);",
            "    ",
            "        tree[node].merge(tree[node << 1], tree[node << 1 | 1]);",
            "    }",
            "    ",
            "    void update(long long pos, long long val){",
            "        update(1, 0, n-1, pos, val);",
            "    }",
            "    ",
            "    void update(long long node, long long l, long long r, long long pos, long long val){",
            "        if(l == r){",
            "            tree[node].update(val);",
            "            return;",
            "        }",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        if(pos <= mid){",
            "            update(node << 1, l, mid, pos, val);",
            "        }else{",
            "            update(node << 1 | 1, mid + 1, r, pos, val);",
            "        }",
            "    ",
            "        tree[node].merge(tree[node << 1], tree[node << 1 | 1]);",
            "    }",
            "    ",
            "    long long query(long long s, long long e){",
            "        segNode ans = query(1, 0, n-1, s, e);",
            "        ",
            "        return ans.sum;",
            "    }",
            "    ",
            "    segNode query(long long node, long long l, long long r, long long s, long long e){",
            "        if(l >= s && r <= e) return tree[node];",
            "    ",
            "        if(l > e || r < s) return segNode();",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "    ",
            "        segNode ans, left, right;",
            "        left = query(node << 1, l, mid, s, e);",
            "        right = query(node << 1 | 1, mid + 1, r, s, e);",
            "        ans.merge(left, right);",
            "        ",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Segment tree"
    },
    "Segment tree Lazy": {
        "prefix": "Segment tree Lazy",
        "body": [
            "struct segNode{",
            "    long long sum, set;",
            "    ",
            "    segNode(){",
            "        sum = 0;",
            "        set = -1;",
            "    }",
            "    ",
            "    segNode(long long x){",
            "        sum = x;",
            "        set = -1;",
            "    }",
            "    ",
            "    void merge(segNode &a, segNode &b){",
            "        sum = a.sum + b.sum;",
            "    }",
            "    ",
            "    void lazy_add(ll x){",
            "        set = x;",
            "    }",
            "    ",
            "    void lazy_apply(ll l, ll r){",
            "        if(set != -1){",
            "            sum = (r - l + 1) * set;",
            "        }",
            "    }",
            "    ",
            "    void lazy_merge(segNode &par){",
            "        if(par.set != -1) set = par.set;",
            "    }",
            "    ",
            "    void lazy_remove(){",
            "        set = -1;",
            "    }",
            "}; ",
            " ",
            "class segTree{",
            "    public:",
            "    vector<segNode> tree;",
            "    long long n;",
            "    ",
            "    segTree(long long n){",
            "        this -> n = n;",
            "        tree.resize(4 * n, segNode());",
            "    ",
            "        build(1, 0, n-1);",
            "    }",
            "    ",
            "    void build(long long node, long long l, long long r){",
            "        if(l == r){",
            "            tree[node] = segNode(0);",
            "            return;",
            "        }",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        build(node << 1, l, mid);",
            "        build(node << 1 | 1, mid + 1, r);",
            "    ",
            "        tree[node].merge(tree[node << 1], tree[node << 1 | 1]);",
            "    }",
            "    ",
            "    void push(long long node, long long l, long long r){",
            "        tree[node].lazy_apply(l, r);",
            "    ",
            "        if(l != r){",
            "            tree[node << 1].lazy_merge(tree[node]);",
            "            tree[node << 1 | 1].lazy_merge(tree[node]);",
            "        }",
            "    ",
            "        tree[node].lazy_remove();",
            "    }",
            "    ",
            "    void update(long long s, long long e, long long x){",
            "        update(1, 0, n-1, s, e, x);",
            "    }",
            "    ",
            "    void update(long long node, long long l, long long r, long long s, long long e, long long x){",
            "        push(node, l, r);",
            "    ",
            "        if(l > e || r < s) return;",
            "        if(l >= s && r <= e){",
            "            tree[node].lazy_add(x);",
            "            push(node, l, r);",
            "            return;",
            "        }",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        update(node << 1, l, mid, s, e, x);",
            "        update(node << 1 | 1, mid + 1, r, s, e, x);",
            "    ",
            "        tree[node].merge(tree[node << 1], tree[node << 1 | 1]);",
            "    }",
            "    ",
            "    long long query(long long s, long long e){",
            "        return query(1, 0, n-1, s, e).sum;",
            "    }",
            "    ",
            "    segNode query(long long node, long long l, long long r, long long s, long long e){",
            "        push(node, l, r);",
            "    ",
            "        if(l > e || r < s) return segNode();",
            "        if(l >= s && r <= e) return tree[node];",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        segNode ans, left, right;",
            "        left = query(node << 1, l, mid, s, e);",
            "        right = query(node << 1 | 1, mid + 1, r, s, e);",
            "    ",
            "        ans.merge(left, right);",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Segment tree Lazy"
    },
    "Fenwick Tree": {
        "prefix": "Fenwick Tree",
        "body": [
            "// Fenwick Tree",
            "struct FenwickTree {",
            "    long long n;",
            "    vector<long long> s;",
            "    FenwickTree(int n) : s(n), n(n) {}",
            "",
            "    // v[pos] += dif",
            "    void update(int pos, long long dif) { ",
            "        for (; pos < n; pos += (pos & -pos)) s[pos] += dif;",
            "    }",
            "",
            "    // sum of values in [1, pos]",
            "    long long query(int pos) { ",
            "        long long res = 0;",
            "        for (; pos > 0; pos -= (pos & -pos)) res += s[pos];",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Fenwick Tree"
    },
    "Sparse Table": {
        "prefix": "Sparse Table",
        "body": [
            "class SparseTable{",
            "    vector<vector<long long>> st;",
            "    vector<long long> lg;",
            "    long long K;",
            "    ",
            "    public:",
            "",
            "    SparseTable(vector<long long> &v, ll &n){",
            "        K = 20; // 20 for 2 * 1e5, 25 for 1e7, and so on..",
            "        st.resize(K + 1, vector<long long> (n));",
            "        lg.resize(n + 1);",
            "        preComputeLG(n);",
            "        preCompute(v, n);",
            "    }",
            "",
            "    void preComputeLG(long long &n){",
            "        lg[0] = 1;",
            "        for (long long i = 2; i <= n; i++){",
            "            lg[i] = lg[i/2] + 1;",
            "        }",
            "    }",
            "",
            "    void preCompute(vector<long long> &v, long long &n){",
            "        // st[i][j] -> range [j, j + (1long long << i) - 1]",
            "        // st[i][j] = st[i-1][j] + st[i-1][j + (1long long << (i-1))];",
            "",
            "        copy(v.begin(), v.end(), st[0].begin());",
            "",
            "        for(long long i = 1; i <= K; ++i){",
            "            for(long long j = 0; j + (1ll << i) <= n; ++j){",
            "                st[i][j] = min(st[i-1][j], st[i-1][j + (1ll << (i - 1))]);",
            "            }",
            "        }",
            "    }",
            "",
            "    // 0 - based indexing use for call function",
            "    long long query(long long l, long long r){",
            "        // sum query",
            "        // long long sum = 0;",
            "        // for (long long i = K; i >= 0; i--) {",
            "        //     if ((1 << i) <= R - L + 1) {",
            "        //         sum += st[i][L];",
            "        //         L += 1 << i;",
            "        //     }",
            "        // }",
            "",
            "        // for idempotent functions like min, max, gcd, bitwise and, bitwise or, etc...",
            "        long long i = lg[r - l + 1];",
            "        long long mn = min(st[i][l], st[i][r - (1 << i) + 1]);",
            "        return mn;",
            "    }",
            "};"
        ],
        "description": "Sparse Table"
    },
    "Hash String": {
        "prefix": "Hash String",
        "body": [
            "class HashString{",
            "    long long p = 31, m = 1e9+9;",
            "    vector<long long> h, ppow;",
            "    public:",
            " ",
            "    HashString(string &s){",
            "        int n = s.length();",
            "        h.resize(n + 1, 0);",
            "        ppow.resize(n + 1, 0);",
            "        ppow[0] = 1;",
            " ",
            "        for(int i = 1; i <= n; ++i){",
            "            ppow[i] = (ppow[i - 1] * p) % m;",
            "            h[i] = ((h[i - 1] * p) % m + (s[i - 1] - 'a' + 1)) % m;",
            "        }",
            "    }   ",
            "    ",
            "    // assume zero based indexing",
            "    long long getSubHash(int l, int r){ ",
            "        long long ans = (h[r + 1] - (h[l] * ppow[r - l + 1]) % m + m) % m;",
            "        return ans;",
            "    }",
            " ",
            "    long long getInstantHash(string &s){",
            "        long long ans = 0;",
            " ",
            "        for(auto &c : s){",
            "            ans = (ans * p) % m;",
            "            ans = (ans + (c - 'a' + 1)) % m;",
            "        }",
            " ",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Hash String"
    },
    "KMP Algo Prefix Function": {
        "prefix": "KMP Algo Prefix Function",
        "body": [
            "// Knuth-Morris-Pratt algorithm",
            "vector<long long> prefixFunction(string &s){",
            "    // pref till that index (ex. abcabc = 000123)",
            "    long long n = s.length();",
            "    vector<long long> pi(n);",
            "    pi[0] = 0;",
            "    for(long long i = 1; i < n; ++i){",
            "        long long j = pi[i-1];",
            "        while(j > 0 && s[i] != s[j]){",
            "            j = pi[j-1];",
            "        }",
            "        if(s[i] == s[j]){",
            "            j++;",
            "        }",
            "        pi[i] = j;",
            "    }",
            "    return pi;",
            "}"
        ],
        "description": "KMP Algo Prefix Function"
    },
    "Z Algorithm": {
        "prefix": "Z Algorithm",
        "body": [
            "vector<long long> z_function(string &s, long long n){",
            "    vector<long long> z(n);",
            "    z[0] = 0;",
            "    long long l = 0, r = 0;",
            "    for(long long i = 1; i < n; ++i){",
            "        if(i < r){",
            "            z[i] = min(r - i, z[i - l]);",
            "        }",
            "        while(i + z[i] < n && s[z[i]] == s[i + z[i]]){",
            "            z[i]++;",
            "        }",
            "        if(i + z[i] > r){",
            "            l = i;",
            "            r = i + z[i];",
            "        }",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Z Algorithm"
    },
    "LCA Lowest Common Ancestor": {
        "prefix": "LCA Binary Lifting",
        "body": [
            "// LCA using in out time",
            "const long long nodesCnt = 2e5 + 5;",
            "long long par[nodesCnt][20]; // 20 for 2 * 1e5, 25 for 1e7, and so on..",
            "long long in[nodesCnt], out[nodesCnt];",
            "long long timer;",
            "",
            "// Initialization ",
            "// timer = 0;",
            "// preDfs(1, 1, adj)",
            "",
            "// 1 - based indexing for nodes",
            "void preDfs(long long u, long long p, vector<vector<long long>> &adj){",
            "    in[u] = ++timer;",
            "    par[u][0] = p;",
            "    ",
            "    for(long long i = 1; i < 20; ++i){",
            "        par[u][i] = par[par[u][i-1]][i-1];",
            "    }",
            "    ",
            "    for(auto &v : adj[u]){",
            "        if(v == p) continue;",
            "        preDfs(v, u, adj);",
            "    }",
            "",
            "    out[u] = ++timer;",
            "}",
            " ",
            "bool is_ancestor(long long u, long long v){",
            "    return (in[u] <= in[v] && out[u] >= out[v]);",
            "}",
            " ",
            "long long lca(long long u, long long v){",
            "    if(is_ancestor(u, v)) return u;",
            "    if(is_ancestor(v, u)) return v;",
            "    ",
            "    for(long long i = 19; i >= 0; --i){",
            "        if(!is_ancestor(par[u][i], v)){",
            "            u = par[u][i];",
            "        }",
            "    }",
            "    ",
            "    return par[u][0];",
            "}"
        ],
        "description": "LCA Lowest Common Ancestor"
    },
    "Random Number Generator": {
        "prefix": "Random Number Generator",
        "body": [
            "// unsigned long long random number, usage: rng()",
            "mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());"
        ],
        "description": "Random Number Generator"
    },
    "Mo's Algorithm": {
        "prefix": "Mo's Algorithm",
        "body": [
            "// Mo's Algorithm",
            "const ll BLOCK_SIZE = 500; // sqrt(n) or some near value",
            "",
            "// TODO: Data structures for Mo's algo",
            "",
            "// TODO: remove value at idx from data structure",
            "void remove(ll idx){",
            "",
            "};",
            "",
            "// TODO: add value at idx from data structure",
            "void add(ll idx){",
            "",
            "};",
            "",
            "// TODO: extract the current answer of the data structure",
            "ll get_answer(){",
            "",
            "}; ",
            "",
            "// l, r -> 0 based indexing",
            "struct Query { ",
            "    ll l, r, idx;",
            "    bool operator<(Query other) const",
            "    {",
            "        return make_pair(l / BLOCK_SIZE, r) <",
            "               make_pair(other.l / BLOCK_SIZE, other.r);",
            "    }",
            "};",
            "",
            "vector<ll> mo_s_algorithm(vector<Query> queries) {",
            "    vector<ll> answers(queries.size());",
            "    sort(queries.begin(), queries.end());",
            "",
            "    // TODO: initialize data structure",
            "",
            "    ll cur_l = 0;",
            "    ll cur_r = -1;",
            "    // invariant: data structure will always reflect the range [cur_l, cur_r]",
            "    for (Query q : queries) {",
            "        while (cur_l > q.l) {",
            "            cur_l--;",
            "            add(cur_l);",
            "        }",
            "        while (cur_r < q.r) {",
            "            cur_r++;",
            "            add(cur_r);",
            "        }",
            "        while (cur_l < q.l) {",
            "            remove(cur_l);",
            "            cur_l++;",
            "        }",
            "        while (cur_r > q.r) {",
            "            remove(cur_r);",
            "            cur_r--;",
            "        }",
            "        answers[q.idx] = get_answer();",
            "    }",
            "    return answers;",
            "}"
        ],
        "description": "Mo's Algorithm"
    },
    "Smallest Prime Factor Sieve": {
        "prefix": "spf sieve",
        "body": [
            "// Smallest Prime Factor Sieve",
            "const long long spfSize = 1e7+1;",
            "long long spf[spfSize];",
            "",
            "void preComputeSPF(){",
            "    for(long long i = 0; i < spfSize; ++i) spf[i] = i;",
            "    for(long long i = 2; i < spfSize; ++i){",
            "        if(spf[i] == i){",
            "            for(long long j = i * i; j < spfSize; j += i){",
            "                if(spf[j] == j) spf[j] = i;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Smallest Prime Factor Sieve"
    },
    "Matrix Exponentiation": {
        "prefix": "Matrix Exponentiation",
        "body": [
            "// Matrix Exponentiation",
            "vector<vector<long long>> matPower(vector<vector<long long>> a, long long b, long long mod){",
            "    long long n = a.size();",
            "    vector<vector<long long>> res(n, vector<long long>(n, 0));",
            "    for(long long i = 0; i < n; ++i) res[i][i] = 1;",
            "",
            "    while(b > 0){",
            "        if(b & 1){",
            "            vector<vector<long long>> res2(n, vector<long long>(n, 0));",
            "            for(long long i = 0; i < n; ++i){",
            "                for(long long j = 0; j < n; ++j){",
            "                    for(long long k = 0; k < n; ++k){",
            "                        res2[i][j] = (res2[i][j] + (res[i][k] * a[k][j]) % mod) % mod;",
            "                    }",
            "                }",
            "            }",
            "            res = res2;",
            "        }",
            "",
            "        vector<vector<long long>> a2(n, vector<long long>(n, 0));",
            "        for(long long i = 0; i < n; ++i){",
            "            for(long long j = 0; j < n; ++j){",
            "                for(long long k = 0; k < n; ++k){",
            "                    a2[i][j] = (a2[i][j] + (a[i][k] * a[k][j]) % mod) % mod;",
            "                }",
            "            }",
            "        }",
            "        a = a2;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Matrix Exponentiation"
    },
    "Matrix Multiplication": {
        "prefix": "Matrix Multiplication",
        "body": [
            "// Matrix Multiplication",
            "vector<vector<long long>> matMultiply(vector<vector<long long>> &a, vector<vector<long long>> &b, long long mod){",
            "    assert(a[0].size() == b.size());",
            "    long long n = a.size(), m = a[0].size(), k = b[0].size();",
            "    vector<vector<long long>> res(n, vector<long long>(k, 0));",
            "    for(long long i = 0; i < n; ++i){",
            "        for(long long j = 0; j < k; ++j){",
            "            for(long long l = 0; l < m; ++l){",
            "                res[i][j] = (res[i][j] + (a[i][l] * b[l][j]) % mod) % mod;",
            "            }",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Matrix Multiplication"
    },
    "FFT - Fast Fourier Transform": {
        "prefix": "FFT",
        "body": [
            "// FFT - Fast Fourier Transform",
            "// Multiply two polynomials in O(n log n)",
            "class FFT{",
            " ",
            "    const double PI = acos(-1);",
            "    struct base{",
            " ",
            "        double a, b;",
            "        base(double a = 0, double b = 0) : a(a), b(b) {}",
            "        const base operator+(const base &c) const {",
            "            return base(a + c.a, b + c.b);",
            "        }",
            "        const base operator-(const base &c) const {",
            "            return base(a - c.a, b - c.b);",
            "        }",
            "        const base operator*(const base &c) const {",
            "            return base(a * c.a - b * c.b, a * c.b + b * c.a);",
            "        }",
            "    };",
            " ",
            "    public:",
            " ",
            "    void fft(vector<base> &p, bool inv = 0){",
            "        int n = p.size(), i = 0;",
            " ",
            "        // bit reverse permutation",
            "        for (int j = 1; j < n - 1; ++j){",
            "            for (int k = n >> 1; k > (i ^= k); k >>= 1);",
            "            if (j < i) swap(p[i], p[j]);",
            "        }",
            " ",
            "        for (int len = 2, l = 1; len <= n; len <<= 1, l <<= 1){",
            "            double ang = 2 * PI / len;",
            "            base wn = base(cos(ang), (inv ? 1. : -1.) * sin(ang)), w;",
            "            for (int i = 0, j; i < n; i += len){",
            "                for (w = base(1, 0), j = i; j < i + l; ++j, w = w * wn)",
            "                {",
            "                    base t = w * p[j + l];",
            "                    p[j + l] = p[j] - t;",
            "                    p[j] = p[j] + t;",
            "                }",
            "            }",
            "        }",
            " ",
            "        if (inv){",
            "            for (int i = 0; i < n; ++i){",
            "                p[i].a /= n, p[i].b /= n;",
            "            }",
            "        }       ",
            "    }",
            " ",
            "    vector<long long> multiply(vector<long long> &a, vector<long long> &b){",
            "        int n = a.size(), m = b.size(), sz = 1;",
            "        while (sz < n + m - 1) sz <<= 1;",
            "        vector<base> x(sz), y(sz), z(sz);",
            "        for (int i = 0; i < sz; ++i){",
            "            x[i] = i < n ? base(a[i], 0) : base(0, 0);",
            "            y[i] = i < m ? base(b[i], 0) : base(0, 0);",
            "        }",
            "        fft(x), fft(y);",
            "        for (int i = 0; i < sz; ++i) z[i] = x[i] * y[i];",
            "        fft(z, 1);",
            " ",
            "        vector<long long> ret(n + m - 1);",
            "        for (int i = 0; i < n + m - 1; ++i) ret[i] = (long long)round(z[i].a);",
            "        return ret;",
            "    }",
            "};"
        ],
        "description": "FFT - Fast Fourier Transform"
    },
    "Segment Tree Beats": {
        "prefix": "Segment Tree Beats",
        "body": [
            "",
            "// Segment Tree Beats",
            "",
            "/*",
            "Usage:",
            "",
            "Build the segment tree with build() function.",
            "",
            "update_add(l, r, v) - a[i] = a[i] + v",
            "update_chmin(l, r, v) - a[i] = min(a[i], v)",
            "update_chmax(l, r, v) - a[i] = max(a[i], v)",
            "query_sum(l, r) -  sum of a[i] for i in [l, r]",
            "",
            "Note: 0-based indexing",
            "*/",
            "",
            "const int MAXN = 200001;",
            "ll A[MAXN];",
            "",
            "struct Node{",
            "    ll sum;  // Sum tag",
            "    ll max1; // Max value",
            "    ll max2; // Second Max value",
            "    ll maxc; // Max value count",
            "    ll min1; // Min value",
            "    ll min2; // Second Min value",
            "    ll minc; // Min value count",
            "    ll lazy; // Lazy tag",
            "} T[MAXN * 4];",
            "",
            "void merge(int t){",
            "    // sum",
            "    T[t].sum = T[t << 1].sum + T[t << 1 | 1].sum;",
            "",
            "    // max",
            "    if (T[t << 1].max1 == T[t << 1 | 1].max1){",
            "        T[t].max1 = T[t << 1].max1;",
            "        T[t].max2 = max(T[t << 1].max2, T[t << 1 | 1].max2);",
            "        T[t].maxc = T[t << 1].maxc + T[t << 1 | 1].maxc;",
            "    }",
            "    else{",
            "        if (T[t << 1].max1 > T[t << 1 | 1].max1){",
            "            T[t].max1 = T[t << 1].max1;",
            "            T[t].max2 = max(T[t << 1].max2, T[t << 1 | 1].max1);",
            "            T[t].maxc = T[t << 1].maxc;",
            "        }",
            "        else{",
            "            T[t].max1 = T[t << 1 | 1].max1;",
            "            T[t].max2 = max(T[t << 1].max1, T[t << 1 | 1].max2);",
            "            T[t].maxc = T[t << 1 | 1].maxc;",
            "        }",
            "    }",
            "",
            "    // min",
            "    if (T[t << 1].min1 == T[t << 1 | 1].min1){",
            "        T[t].min1 = T[t << 1].min1;",
            "        T[t].min2 = min(T[t << 1].min2, T[t << 1 | 1].min2);",
            "        T[t].minc = T[t << 1].minc + T[t << 1 | 1].minc;",
            "    }",
            "    else{",
            "        if (T[t << 1].min1 < T[t << 1 | 1].min1){",
            "            T[t].min1 = T[t << 1].min1;",
            "            T[t].min2 = min(T[t << 1].min2, T[t << 1 | 1].min1);",
            "            T[t].minc = T[t << 1].minc;",
            "        }",
            "        else{",
            "            T[t].min1 = T[t << 1 | 1].min1;",
            "            T[t].min2 = min(T[t << 1].min1, T[t << 1 | 1].min2);",
            "            T[t].minc = T[t << 1 | 1].minc;",
            "        }",
            "    }",
            "}",
            "",
            "void push_add(int t, int tl, int tr, ll v){",
            "    if (v == 0){",
            "        return;",
            "    }",
            "    T[t].sum += (tr - tl + 1) * v;",
            "    T[t].max1 += v;",
            "    if (T[t].max2 != -llINF){",
            "        T[t].max2 += v;",
            "    }",
            "    T[t].min1 += v;",
            "    if (T[t].min2 != llINF){",
            "        T[t].min2 += v;",
            "    }",
            "    T[t].lazy += v;",
            "}",
            "",
            "// corresponds to a chmin update",
            "void push_max(int t, ll v, bool l){",
            "    if (v >= T[t].max1){",
            "        return;",
            "    }",
            "    T[t].sum -= T[t].max1 * T[t].maxc;",
            "    T[t].max1 = v;",
            "    T[t].sum += T[t].max1 * T[t].maxc;",
            "    if (l){",
            "        T[t].min1 = T[t].max1;",
            "    }",
            "    else{",
            "        if (v <= T[t].min1){",
            "            T[t].min1 = v;",
            "        }",
            "        else if (v < T[t].min2){",
            "            T[t].min2 = v;",
            "        }",
            "    }",
            "}",
            "",
            "// corresponds to a chmax update",
            "void push_min(int t, ll v, bool l){",
            "    if (v <= T[t].min1){",
            "        return;",
            "    }",
            "    T[t].sum -= T[t].min1 * T[t].minc;",
            "    T[t].min1 = v;",
            "    T[t].sum += T[t].min1 * T[t].minc;",
            "    if (l){",
            "        T[t].max1 = T[t].min1;",
            "    }",
            "    else{",
            "        if (v >= T[t].max1){",
            "            T[t].max1 = v;",
            "        }",
            "        else if (v > T[t].max2){",
            "            T[t].max2 = v;",
            "        }",
            "    }",
            "}",
            "",
            "void pushdown(int t, int tl, int tr){",
            "    if (tl == tr)",
            "        return;",
            "    // sum",
            "    int tm = (tl + tr) >> 1;",
            "    push_add(t << 1, tl, tm, T[t].lazy);",
            "    push_add(t << 1 | 1, tm + 1, tr, T[t].lazy);",
            "    T[t].lazy = 0;",
            "",
            "    // max",
            "    push_max(t << 1, T[t].max1, tl == tm);",
            "    push_max(t << 1 | 1, T[t].max1, tm + 1 == tr);",
            "",
            "    // min",
            "    push_min(t << 1, T[t].min1, tl == tm);",
            "    push_min(t << 1 | 1, T[t].min1, tm + 1 == tr);",
            "}",
            "",
            "void build(int t = 1, int tl = 0, int tr = MAXN - 1){",
            "    T[t].lazy = 0;",
            "    if (tl == tr){",
            "        T[t].sum = T[t].max1 = T[t].min1 = A[tl];",
            "        T[t].maxc = T[t].minc = 1;",
            "        T[t].max2 = -llINF;",
            "        T[t].min2 = llINF;",
            "        return;",
            "    }",
            "",
            "    int tm = (tl + tr) >> 1;",
            "    build(t << 1, tl, tm);",
            "    build(t << 1 | 1, tm + 1, tr);",
            "    merge(t);",
            "}",
            "",
            "void update_add(int l, int r, ll v, int t = 1, int tl = 0, int tr = MAXN - 1){",
            "    if (r < tl || tr < l){",
            "        return;",
            "    }",
            "    if (l <= tl && tr <= r){",
            "        push_add(t, tl, tr, v);",
            "        return;",
            "    }",
            "    pushdown(t, tl, tr);",
            "",
            "    int tm = (tl + tr) >> 1;",
            "    update_add(l, r, v, t << 1, tl, tm);",
            "    update_add(l, r, v, t << 1 | 1, tm + 1, tr);",
            "    merge(t);",
            "}",
            "",
            "void update_chmin(int l, int r, ll v, int t = 1, int tl = 0, int tr = MAXN - 1){",
            "    if (r < tl || tr < l || v >= T[t].max1){",
            "        return;",
            "    }",
            "    if (l <= tl && tr <= r && v > T[t].max2){",
            "        push_max(t, v, tl == tr);",
            "        return;",
            "    }",
            "    pushdown(t, tl, tr);",
            "",
            "    int tm = (tl + tr) >> 1;",
            "    update_chmin(l, r, v, t << 1, tl, tm);",
            "    update_chmin(l, r, v, t << 1 | 1, tm + 1, tr);",
            "    merge(t);",
            "}",
            "",
            "void update_chmax(int l, int r, ll v, int t = 1, int tl = 0, int tr = MAXN - 1){",
            "    if (r < tl || tr < l || v <= T[t].min1){",
            "        return;",
            "    }",
            "    if (l <= tl && tr <= r && v < T[t].min2){",
            "        push_min(t, v, tl == tr);",
            "        return;",
            "    }",
            "    pushdown(t, tl, tr);",
            "",
            "    int tm = (tl + tr) >> 1;",
            "    update_chmax(l, r, v, t << 1, tl, tm);",
            "    update_chmax(l, r, v, t << 1 | 1, tm + 1, tr);",
            "    merge(t);",
            "}",
            "",
            "ll query_sum(int l, int r, int t = 1, int tl = 0, int tr = MAXN - 1){",
            "    if (r < tl || tr < l){",
            "        return 0;",
            "    }",
            "    if (l <= tl && tr <= r){",
            "        return T[t].sum;",
            "    }",
            "    pushdown(t, tl, tr);",
            "",
            "    int tm = (tl + tr) >> 1;",
            "    return query_sum(l, r, t << 1, tl, tm) + query_sum(l, r, t << 1 | 1, tm + 1, tr);",
            "}",
            ""
        ],
        "description": "Segment Tree Beats"
    }
}